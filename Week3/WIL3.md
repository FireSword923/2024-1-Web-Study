3주차에서 배운 것
==================
# JavaScript와 브라우저의 관계
자바스크립트 코드를 이용해 함수를 실행하려고 할 경우
아래의 3개의 단계를 거친다.

1. Stack에 순서대로 JavaScript 코드를 쌀음
2. 코드를 웹이 제공하는 API Callback Queue에 넣음
3. Stack이 비어 있는 시간에 Event Loop 작동시켜 Callback Queue에서 콜백 함수 실행

**스택이 비어 있는 시간**에 함수가 실행되는 것이기 때문에 
```
{JavaScriopt}

setTimeout(fuction() {
    console.log("first")
}, 0)
console.log("second")
```
코드를 실행할 시 **second**가 먼저 출력된다.

# HTTP란?
Hyper Text Transfer Protocol의 약자, HTML을 전달할 수 있는 프로토콜이라는 뜻이다.

## HTTP의 버전
현대에서 가장 많이 쓰이는 **버전은 HTTP/1.1**이며,
HTTP/2, HTTP/3도 있으나 아직은 1.1을 바탕으로 하고 있다.

    그러나 2022년 6월, HTTP/3가 IETF의 표준이 됐기에, 어느정도 준비를 할 필요성은 있다,

### 프로토콜 별 사용 버전
* TCP: HTTP/1.1, HTTP/2
* UDP: HTTP/3

#### TCP란?
* 3 way handshake를 통하여 연결 지향적

    **3 way handshake란?**
    1. 클라이언트 컴퓨터가 서버에 접속 요청
    2. 서버가 클라이언트 컴퓨터에 접속 수락 및 요청
    3. 클라이언트 컴퓨터가 서버에 접속 수락

* 데이터 전달을 보증하여, 누락을 알 수 있도록 함
* 데이터 전달의 순서를 보장함

#### UDP란?
TCP에사 3 way handshake를 뺸 것

# 채팅기능에 필요한 프로토콜들
    1. 애플리케이션 계층 - HTTP, FTP
    2. 전송 계층 - TCP, UDP, IP
    3. 인터넷 계층 - IP
    4. 네트워크 인터페이스 계층

## HTTP, FTP
메세지 입력시 메세지가 **소켓**에 전달됨

## TCP, UDP, IP
    1. 메세지가 TCP 정보를 가지게 된다.
    2. IP 패킷을 생성하게 된다.

### TCP 패킷 정보
    1. 출발지 port 번호
    2. 목적지 port 번호
    3. 전송 제어 정보
    4. 전송 순서
    5. 검증 관련 정보

### IP 패킷 정보
    1. 출발지 IP 주소
    2. 도착지 IP 주소

# HTTP의 특징
## 클라이언트 & 서버 구조
클라이언트가 서버에 요청 보내고, 서버에게 응답을 받음

## Stateless(무상태)
서버는 클라이언트의 상태를 보존하고 있지 않다. 클라이언트 컴퓨터가 로컬 저장소로서 역할하는 중계 서버를 갖고 있고, 그 중계 서버가 여러 서버 중 아무 곳에 요청을 보낸다.

## 비연결
클라이언트와 서버는 평소에는 연결 돼있지 않고, 필요할 때만 열결된다. 

다만 TCP/IP 연결을 계속 해야해서 3 way handshake 시간이 추가되고, 브라우저를 로드할 때 가져오는 소스가 많다는 단점이 있다.

따라서 요즘 HTTP는 필요한 자원들을 모두 다운로드 받을 때까지 연결을 종료하지 않고, 필요한 작업이 모두 끝났을 때 연결을 종료하도록 설계돼있다.

# HTTP API, Method
## URL 만들기
URL은 리소스를 식별하는 인식표이다. 따라서 URL을 만들 때 겹치는 리소스가 있을 경우 효율적으로 URL을 만들기 위해 그 리소스를 기준으로 이름을 지어 만든다.

예를 들어 member라는 리소스가 여러 개 있을 경우
/members, /members/{id}, /members/{id}, /members/{id} ... 등으로 짓는다.

**행위**는 **메서드**를 통해 식별한다.

## Method
### GET
정보를 조회하기 위한 메서드. 서버에 전달할 데이터는 **query**로 보낸다. **body**를 잘 쓰지 않는다.

ex) https://search.naver.com/search.naver?query=뉴진스

### POST
요청을 처리하기 위한 메서드. 서버에 전달할 데이터는 **body**로 보낸다. 전잘된 데이터를 통해 리소스를 관리한다.

이 메서드의 주요 기능은
* 새로운 리소스 등록
* 상태 변경
* 다른 메서드를 쓰기 어려운 경우 대신 사용

### PUT
리소스를 대체하는 메서드. 리소스가 있으면 대체하고, 없으면 새로 생성한다. URL 생성시 POST ID와 같은 것으로 지정한다.

ex) https://blog.naver.com/RabbitWrite.naver/**1**

### PATCH
리소스를 부분 대체하는 메서드. 말 그대로 일부 리소스만 대체한다.

### DELETE
리소스를 제거하는 메서드.

# 과제
## HTTP 메서드 사용 사례 정리
1. GET 메서드 - 네이버 검색
 ![사이트 사진](https://github.com/FireSword923/2024-1-Web-Study/blob/main/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-05-27%20010428.png)

2. POST 메서드 - 파파고 번역
 ![사이트 사진](https://github.com/FireSword923/2024-1-Web-Study/blob/main/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-05-27%20010724.png)

3. PUT 메서드 - GIthub에 코드 업로드

 ## HTTP/1.1, /2, /3의 차이점과 역사
* HTTP/1.1 : 1999년에 출시됐다. 상당히 간단하지만, 그만큼 비효율적이고 우선 순위를 정할 수 없다.

* HTTP/2 : HTTP/1.1의 여러 문제점들을 해결하기 위해 2015년에 출시됐다. 여러 자료들을 동시에 요청하여 동시에 받는 멀티플렉싱 기능이 있다. 또한 데이터 통신량을 줄이고 우선 순위 지정도 가능하다.

* HTTP/3 : 2020년 10월에 초안으로 등장. TCP 대신 UDP를 사용한다. 여기엔 내장 암호화 기능 등등의 장점이 있으나 UDP를 지원하는 네트워크들이 적다는 문제가 있다.

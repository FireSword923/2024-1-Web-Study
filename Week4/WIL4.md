4주차
=============
# 상태 코드
클라이언트가 보낸 요청의 처리 상태를 알려주는 코드
* 1xx: 요청 처리 중
* 2xx: 요청 정상 처리
* 3xx: 추가 행동 필요
* 4xx: 클라이언트 오류, 문법 등에 문제가 있음
* 5xx: 서버 오류

## 클라이언트가 인식 못 하는 상태코드
위의 상태코드로 해석 가능하다.
ex) 299: 요청 정상 처리, 461: 클라이언트 오류, etc.

## 1xx
작업 진행 중임을 나타내는 정보 제공의 목적 코드다.
잘 사용하지 않는다.

## 2xx
### 200 OK
요청 성공적 처리.
### 201 Created
요청 처리 뒤 새로운 리소스가 생성됨.
### 202 Accepted
요청 접수됨, 처리 중.
### 204 No content
처리 성공, 그러나 응답 body에 아무 내용도 없음.

## 3xx
클라이언트의 요청을 마치기 위해 추가 동작 필요한 상태.
### 300 Multiple Choices
선택 항목 여러 개.
### 301 Moved Permanently
지정 리소스가 새로운 URL로 영구적 이동.
### 302 Found
다른 위치로 요청 진행, 브라우저의 폼 요청을 POST 처리 후 리다이렉트.
### 304 Not Modified
마지막 요청 이후 페이지 수정 x
### 305 Use Proxy
지정 리소스에 액세스하려면 프록시를 통해야 함.
### 307 Templrary Redirect
임시로 리다이렉션 요청 필요, 리다이렉트 시 요청 메서드 유지.
#### 리다이렉션
리소스의 URL이 변경되는 것.

## 4xx
### 400 Bad Request
요청이 잘못 됐거나, 오타 등으로 오류를 발생시켰을 경우.
### 401 Unauthorized
요청이 해당 리소스에 대한 인증 필요.
www-Authenticate 헤더에 인증 관련 정보를 넣어야 함. like 로그인
### 403 Forbidden
접근 권한이 없을 경우 리소스로 접근 거부됨.
### 404 Not Found 
요청 리소스가 서버에 없거나, 권한이 없어서 리소스를 숨기려고 할 때.

## 5xx
### 500 Internal Server Error
서버의 문제, 대부분 백엔드 에러
### 503 Service Unavailable
서버에 과부하가 걸리거나 서비스 점검 등으로 요청 처리 일시적 불가. Rerty-After 헤더를 통해 언제부터 이용 가능한지 확인 가능.

# HTTP 헤더
## General Header
요청과 응답 모두에 적용, 최종적으로 전송 되는 데이터과 관련 없음.
## Request Header
패치될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더.
## Response Header
위치 또는 서버 자체에 대한 정보같이 응답에 대한 부가적인 정보를 갖는 헤더.
## Representation Header
body message에 대한 자세한 정보 포함
### Request Header의 종류
클라이언트가 이해 가능한 컨텐츠 타입이 뭔지 알려준다. 숫자가 더 크거나 구체적인 것이 우선순위가 높은 것이다.

여기서 얻은 선호 방식 정보를 **최우선순위**에 두고 고려한다.
* Accept: 클라이언트가 선호하는 미디어 타입 전달
* Accept-Charset: 클라이언트가 선호하는 방식의 문자 인코딩
* Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 방식
* Accept-Language: 클라이언트가 선호하는 자연 언어
### Representation Header의 종류
* Content-Type: 표현 데이터 형식
* Content-Encoding: 표현 데이터 압축 방식
* Content-Language: 표현 데이터의 자연 언어
* Content-Length: 표현 데이터 길이

# 쿠키
서버에서 Set-Cookie(응답 헤더)를 통해 클라이언트로 쿠키를 전달하고, 클라이언트가 Cookie를 통해 서버에게 받은 쿠키를 저장, 서버로 전달한다.

이 쿠키를 통해 서버가 정보를 기억하도록 만드는 것이 가능하다.

또한 Set-Cookie 헤더에는 여러가지 플래그가 있다.
* Secure: https인 경우에만 전송.
* HttpOnly: XSS 공격 방지, 자바 스크립트에서 접근 불가능, HTTP에서만 사용.
* SameSite: XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같을 때만 쿠키 전송.

# 캐시
60초의 유효 기간을 가진 데이터를 브라우저 캐시로 전달하고, 60초 이내에 동일 요청이 들어온다면 브라우저 캐시에서 꺼내 사용한다.

쓸때없는 작업을 줄임으로써 시간과 비용 절약.

# 과제
    1. 301, 303요청 시 왜 httpstat.us 페이지의 메인으로 redirect 될까?
    
    그러도록 코딩을 해놔서

    2. 401 요청을 하였을 때, 네트워크 탭의 상태를 보고 어떻게 인증해야 하는지 www-Authenticate 헤더를 기반으로 설명해보자.

    www-Authenticate의 Basic realm = "Fake Realm"이라고 써있으므로 Fake Realm 그룹에 해당하는 권한을 갖고 있다는 것을 인증해야 한다.

    3. Google에 “Hello”를 입력하여 결과물을 보고, 네트워크 요청 탭에서 캐시 관련 정보가 어디에 저장되어 있는지 분석하여 보자.

    네트워크 탭을 본 결과 search?, gogleogo, tia.png 등등에 Cache-Control이 써져있다. 

    4. 더 알고 싶은 상태코드를 직접 체험해보고, 해당 상태코드에서 진행한 요청 헤더, 응답 헤더를 직접 정리하여 분석해보자.

    204 상태코드를 체험한 결과 네트워크 탭에 아무것도 뜨지 않았다.